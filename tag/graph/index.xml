<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>graph | μβ</title>
    <link>https://matbesancon.xyz/tag/graph/</link>
      <atom:link href="https://matbesancon.xyz/tag/graph/index.xml" rel="self" type="application/rss+xml" />
    <description>graph</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 07 Apr 2019 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://matbesancon.xyz/media/icon_hu7565e292f0a230f950fabd03a1d7dda9_12642_512x512_fill_lanczos_center_3.png</url>
      <title>graph</title>
      <link>https://matbesancon.xyz/tag/graph/</link>
    </image>
    
    <item>
      <title>Picking different names with integer optimization</title>
      <link>https://matbesancon.xyz/post/2019-04-07-name_distances/</link>
      <pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate>
      <guid>https://matbesancon.xyz/post/2019-04-07-name_distances/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;I must admit I am not always the most talented at social events.
One point I am especially bad at is &lt;strong&gt;remembering names&lt;/strong&gt;, and it gets
even harder when lots of people have similar or similar-sounding names.
What if we could select a list of people with names as different from each
other as possible?&lt;/p&gt;
&lt;p&gt;First some definitions, &lt;em&gt;different&lt;/em&gt; here is meant with respect to the
&lt;a href=&#34;https://en.wikipedia.org/wiki/Hamming_distance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hamming distance&lt;/a&gt; of any two names.
This is far from ideal since Ekaterina would be quite far from Katerina, but
it will do the trick for now.&lt;/p&gt;
&lt;h2 id=&#34;graph-based-mental-model&#34;&gt;Graph-based mental model&lt;/h2&gt;
&lt;p&gt;This sounds like a problem representable as a complete graph.
The names are the vertices, and the weight associated with each edge $(i,j)$
is the distance between the names of the nodes. We want to take a subset
of $k$ nodes, such that the sum of edge weights for the induced sub-graph
is maximum. This is therefore a particular case of maximum (edge) weight clique
problem over a complete graph, which has been investigated in [1, 2] among others.&lt;/p&gt;
&lt;h2 id=&#34;a-mathematical-optimization-approach&#34;&gt;A mathematical optimization approach&lt;/h2&gt;
&lt;p&gt;This model can be expressed in a pretty compact way:&lt;/p&gt;
&lt;p&gt;$$ \max_{x,y} \sum_{(i,j)\in E} c_{ij} \cdot y_{ij} $$
subject to: $$ 2y_{ij} \leq x_i + x_j ,, \forall (i,j) \in E$$
$$ \sum_{i} x_i \leq k $$
$$x_i, y_{ij} \in \mathbb{B} $$&lt;/p&gt;
&lt;p&gt;The graph is complete and undirected, so the set of edges is:&lt;br&gt;
$ E = $ {$ (i,j) | i \in $ {$ 1..|V| $}$, j \in ${$ 1..i-1 $}}&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s an integer problem with a quadratic number of variables and constraints.
Some other formulations have been proposed, and there may be a specific structure
to exploit given that we have a complete graph.
For the moment though, this generic formulation will do.&lt;/p&gt;
&lt;h2 id=&#34;a-julia-implementation&#34;&gt;A Julia implementation&lt;/h2&gt;
&lt;p&gt;What we want is a function taking a collection of names and returning which
are selected. The first thing to do is build this distance matrix.
We will be using the
&lt;a href=&#34;https://github.com/matthieugomez/StringDistances.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StringDistances.jl&lt;/a&gt;
package not to have to re-implement the Hamming distance.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; StringDistances
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hamming(s1, s2) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; StringDistances&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;evaluate(StringDistances&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Hamming(), s1, s2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; build_dist(vstr, dist &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hamming)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; [dist(vstr[i], vstr[j]) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; eachindex(vstr), j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; eachindex(vstr)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We keep the option to change the distance function with something else later.
The optimization model can now be built, using the distance function and $k$,
the maximum number of nodes to take.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; JuMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; SCIP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; max_clique(dist, k)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Model(with_optimizer(SCIP&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Optimizer))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; size(dist)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@variable&lt;/span&gt;(m, x[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n], Bin)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@variable&lt;/span&gt;(m, y[i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n,j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], Bin)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@constraint&lt;/span&gt;(m, sum(x) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; k)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@constraint&lt;/span&gt;(m, [i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n,j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;y[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x[i] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; x[j])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@objective&lt;/span&gt;(m, Max, sum(y[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; dist[i,j] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n,j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (m, x, y)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I&amp;rsquo;m using SCIP as an integer solver to avoid proprietary software,
feel free to switch it for your favourite one.
Note that we don&amp;rsquo;t optimize the model yet but simply build it.
It is a useful pattern when working with JuMP, allowing users
to inspect the build model or add constraints to it before starting the resolution.
The last steps are straightforward:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dist &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; build_dist(vstr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(m, x, y) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_clique(dist, k)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;optimize!(m) &lt;span style=&#34;color:#75715e&#34;&gt;# solve the problem&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# get the subset of interest&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;diverse_names &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [vstr[i] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; eachindex(vstr) &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; JuMP&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value(x[i]) &lt;span style=&#34;color:#f92672&#34;&gt;≈&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And voilà.&lt;/p&gt;
&lt;h2 id=&#34;trying-out-the-model&#34;&gt;Trying out the model&lt;/h2&gt;
&lt;p&gt;I will use 50 real names taken from
&lt;a href=&#34;http://listofrandomnames.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;the list of random names&lt;/a&gt; website, which you
can find &lt;a href=&#34;https://matbesancon.xyz/text/names.txt&#34;&gt;here&lt;/a&gt;.
The problem becomes large enough to be interesting, but reasonable enough for
a decent laptop. If you want to invite 4 of these people and get the most
different names, Christian, Elizbeth, Beulah and Wilhelmina are the ones you
are looking for.&lt;/p&gt;
&lt;h2 id=&#34;bonus-and-random-ideas&#34;&gt;Bonus and random ideas&lt;/h2&gt;
&lt;p&gt;It is computationally too demanding for now, but it would be interesting
to see how the total sum of distances evolves as you add more people.&lt;/p&gt;
&lt;p&gt;Also, we are using the sum of distances as an objective to maximize.
One interesting alternative would be to maximize the smallest distance between
any two nodes in the subset. This changes the model, since we need to encode
the smallest distance using constraints. We will use an indicator constraint
to represent this:&lt;/p&gt;
&lt;p&gt;$$\max_{x,y} d $$
subject to:
$$ y_{ij} \Rightarrow d \leq c_{ij} ,, \forall (i,j) \in E$$
$$ 2y_{ij} \leq x_i + x_j \forall (i,j) \in E $$
$$ \sum_{(i,j) \in E} y_{ij} = k\cdot (k-1) $$&lt;/p&gt;
&lt;p&gt;Depending on the solver support, the indicator constraint can be modelled directly,
with big M or SOS1 constraints. This remains harder than the initial model.&lt;/p&gt;
&lt;p&gt;Special thanks to Yuan for bringing out the discussion which led to this
post, and to BYP for the feedback.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sources&#34;&gt;Sources&lt;/h1&gt;
&lt;p&gt;[1] Alidaee, Bahram, et al. &amp;ldquo;Solving the maximum edge weight clique problem via unconstrained quadratic  programming.&amp;rdquo; European Journal of Operational Research 181.2 (2007): 592-597.&lt;/p&gt;
&lt;p&gt;[2] Park, Kyungchul, Kyungsik Lee, and Sungsoo Park. &amp;ldquo;An extended formulation approach to the edge-weighted maximal clique problem.&amp;rdquo; European Journal of Operational Research 95.3 (1996): 671-682.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building our own graph type in Julia</title>
      <link>https://matbesancon.xyz/post/2018-08-17-abstract_graph/</link>
      <pubDate>Fri, 17 Aug 2018 00:00:00 +0000</pubDate>
      <guid>https://matbesancon.xyz/post/2018-08-17-abstract_graph/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;This is an adapted post on the talk we gave with &lt;a href=&#34;https://twitter.com/fairbanksjp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;James&lt;/a&gt;
at JuliaCon 2018 in London. You can see the
&lt;a href=&#34;https://matbesancon.xyz/graph_interfaces_juliacon18&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;original slides&lt;/a&gt;,
the video still requires a bit of post-processing.&lt;/p&gt;
&lt;p&gt;Last week &lt;a href=&#34;http://juliacon.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JuliaCon&lt;/a&gt; in London was a great and very condensed experience.
The two talks on &lt;a href=&#34;https://github.com/JuliaGraphs/LightGraphs.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LightGraphs.jl&lt;/a&gt;
received a lot of positive feedback and more than that, we saw
how people are using the library for a variety of use cases which is a great
signal for the work on the JuliaGraphs ecosystem
(see the &lt;a href=&#34;https://matbesancon.xyz/graph_interfaces_juliacon18/ecosystem.html#/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;lightning talk&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I wanted to re-build the same graph for people who prefer a post version to
my clumsy live explanations on a laptop not handling dual-screen well
(those who prefer the latter are invited to see the live-stream of the talk).&lt;/p&gt;
&lt;h2 id=&#34;why-abstractions&#34;&gt;Why abstractions?&lt;/h2&gt;
&lt;p&gt;The LightGraphs library is built to contain as few elements as possible to get
anyone going with graphs. This includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The interface a graph type has to comply with to be used&lt;/li&gt;
&lt;li&gt;Essential algorithms implemented by any graph respecting that interface&lt;/li&gt;
&lt;li&gt;A simple, battery-included implementation based on adjacency lists&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The thing is, if you design an abstraction which in fact has just one
implementation, you&amp;rsquo;re doing abstraction wrong. This talks was also a
reality-check for LightGraphs, are we as composable, extensible as we promised?&lt;/p&gt;
&lt;p&gt;The reason for abstraction is also that &lt;strong&gt;minimalism has its price&lt;/strong&gt;.
The package was designed as the least amount of complexity required to get
graphs working. When people started to use it, obviously they needed more
features, some of which they could code themselves, some other required
extensions built within LightGraphs. By getting the core abstractions right,
you guarantee people will be able to use it and to build on top with minimal
friction, while keeping it simple to read and contribute to.&lt;/p&gt;
&lt;h2 id=&#34;our-matrix-graph-type&#34;&gt;Our matrix graph type&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s recall that a graph is a collection of &lt;em&gt;nodes&lt;/em&gt; and a collection of
&lt;em&gt;edges&lt;/em&gt; between these nodes. To keep it simple, for a graph of $n$ edges,
we will consider they are numbered from 1 to n. An edge connects a node $i$
to a node $j$, therefore all the information of a graph can be kept as an
&lt;em&gt;adjacency matrix&lt;/em&gt; $M_{ij}$ of size $n \times n$:&lt;/p&gt;
&lt;p&gt;$$M_{ij} = \begin{cases} 1, &amp;amp; \mbox{if edge (i $\rightarrow$ j) exists} \\ 0 &amp;amp; \mbox{otherwise}\end{cases}$$&lt;/p&gt;
&lt;p&gt;We don&amp;rsquo;t know what the use cases for our type will be, and therefore,
we will parametrize the graph type over the matrix type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; LightGraphs; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; lg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LightGraphs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mutable struct&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;MT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AbstractMatrix&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;Bool&lt;/span&gt;}} &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lg&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;AbstractGraph&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  matrix&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The edges are simply mapping an entry (i,j) to a boolean (whether there is an
edge from i to j). Even though creating a graph type that can be directed
or undirected depending on the situation is possible, we are creating a type
that will be directed by default.&lt;/p&gt;
&lt;h2 id=&#34;implementing-the-core-interface&#34;&gt;Implementing the core interface&lt;/h2&gt;
&lt;p&gt;We can now implement the core LightGraphs interface for this type, starting
with methods defined over the type itself, of the form &lt;code&gt;function(g::MyType)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m not going to re-define each function here, their meaning can be found
by checking the help in a Julia REPL: &lt;code&gt;?LightGraphs.vertices&lt;/code&gt; or on the
&lt;a href=&#34;http://juliagraphs.github.io/LightGraphs.jl/stable/types.html#AbstractGraph-Type-1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;documentation page&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;is_directed(&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;edgetype(&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SimpleGraphs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SimpleEdge&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ne(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum(g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nv(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; size(g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;vertices(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;nv(g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;edges(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nv(g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SimpleGraphs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SimpleEdge(i,j) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m[i,j])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the last function &lt;code&gt;edges&lt;/code&gt;, for which the documentation specifies that we
need to return an &lt;strong&gt;iterator&lt;/strong&gt; over edges. We don&amp;rsquo;t need to collect the comprehension
in a Vector, returning a lazy generator.&lt;/p&gt;
&lt;p&gt;Some operations have to be defined on both the graph and a node, of the form
&lt;code&gt;function(g::MyType, node)&lt;/code&gt;.
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;outneighbors(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;, node) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [v &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; v &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nv(g) &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m[node, v]]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;inneighbors(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;, node) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [v &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; v &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nv(g) &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m[v, node]]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;has_vertex(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;, v&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Integer&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nv(g) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Out &lt;code&gt;MatrixDiGraph&lt;/code&gt; type is pretty straight-forward to work with and all
required methods are easy to relate to the way information is stored in the
adjacency matrix.&lt;/p&gt;
&lt;p&gt;The last step is implementing methods on both the graph and an edge of the
form &lt;code&gt;function(g::MatrixDiGraph,e)&lt;/code&gt;. The only one we need here is:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;has_edge(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;,i,j) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m[i,j]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2 id=&#34;optional-mutability&#34;&gt;Optional mutability&lt;/h2&gt;
&lt;p&gt;Mutating methods were removed from the core interace some time ago,
as they are not required to describe a graph-like behavior.
The general behavior for operations mutating a graph is to return whether
the operation succeded. They consist in adding or removing elements from
either the edges or nodes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; LightGraphs&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; rem_edge!, rem_vertex!, add_edge!, add_vertex!
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; add_edge!(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;, e)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    has_edge(g,e) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nv(g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (src(e) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; dst(e) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; n) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m[src(e),dst(e)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; rem_edge!(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;,e)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    has_edge(g,e) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nv(g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (src(e) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; dst(e) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; n) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m[src(e),dst(e)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; add_vertex!(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nv(g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Bool&lt;/span&gt;,n&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    m[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n] &lt;span style=&#34;color:#f92672&#34;&gt;.=&lt;/span&gt; g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;testing-our-graph-type-on-real-data&#34;&gt;Testing our graph type on real data&lt;/h2&gt;
&lt;p&gt;We will use the graph type to compute the PageRank of&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; SNAPDatasets
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SNAPDatasets&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loadsnap(&lt;span style=&#34;color:#e6db74&#34;&gt;:ego_twitter_d&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;twitter_graph &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MatrixDiGraph(lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;adjacency_matrix(data)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ranks &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pagerank(twitter_graph)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the broadcast check &lt;code&gt;.==1&lt;/code&gt;, &lt;code&gt;adjacency_matrix&lt;/code&gt; is specified to yield a
matrix of &lt;code&gt;Int&lt;/code&gt;, so we use this to cast the entries to boolean values.&lt;/p&gt;
&lt;p&gt;I took only the first 10 nodes of the graph, but feel free to do the same with
500, 1000 or more nodes, depending on what your machine can stand  🙈&lt;/p&gt;
&lt;h2 id=&#34;overloading-non-mandatory-functions&#34;&gt;Overloading non-mandatory functions&lt;/h2&gt;
&lt;p&gt;Some methods are already implemented for free by implementing the core interface.
That does not mean it should be kept as-is in every case. Depending on your
graph type, some functions might have smarter implementations, let&amp;rsquo;s see one
example. What &lt;code&gt;MatrixDiGraph&lt;/code&gt; is already an &lt;code&gt;adjacency_matrix&lt;/code&gt;, so we know
there should be no computation required to return it (it&amp;rsquo;s almost a no-op).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; BenchmarkTools&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@btime&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@btime&lt;/span&gt; adjacency_matrix(bigger_twitter)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;why did that take so long?&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;adjacency_matrix(g&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MatrixDiGraph&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;m)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@btime&lt;/span&gt; A &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;adjacency_matrix(bigger_twitter)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;that&amp;#39;s better.&amp;#34;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This should yield roughly:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;13.077 ms (5222 allocations: 682.03 KiB)
why did that take so long?
82.077 μs (6 allocations: 201.77 KiB)
that&amp;#39;s better.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can fall down to a no-op by storing the matrix entries as &lt;code&gt;Int&lt;/code&gt; directly,
but the type ends up being a bit heavier in memory, your type, your trade-off.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We&amp;rsquo;ve implemented a graph type suited to our need in a couple lines of Julia,
guided by the &lt;code&gt;LightGraphs&lt;/code&gt; interface specifying &lt;strong&gt;how&lt;/strong&gt; to think about our
graph instead of getting in the way of &lt;strong&gt;what&lt;/strong&gt; to store. A lighter version
of this post can be read as &lt;a href=&#34;https://matbesancon.xyz/graph_interfaces_juliacon18/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;slides&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As usual, ping me on &lt;a href=&#34;https://twitter.com/matbesancon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt; for any
question or comment.&lt;/p&gt;
&lt;h2 id=&#34;bonus&#34;&gt;Bonus&lt;/h2&gt;
&lt;p&gt;If you read this and want to try building your own graph type, here are two
implementations you can try out, put them out in a public repo and show them off
afterwards:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We created a type just for directed graphs, why bothering so much? You can create your own type which can be directed or not,
either by storing the information in the &lt;code&gt;struct&lt;/code&gt; or by parametrizing the type
and getting the compiler to do the work for you.&lt;/li&gt;
&lt;li&gt;We store the entries as an &lt;code&gt;AbstractMatrix{Bool}&lt;/code&gt;, if your graph is dense
enough (how dense? No idea), it might be interesting to store entries as as
&lt;code&gt;BitArray&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;Image source: GraphPlot.jl&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Solving the group expenses headache with graphs</title>
      <link>https://matbesancon.xyz/post/2017-09-11-graph-theory-expenses-management/</link>
      <pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate>
      <guid>https://matbesancon.xyz/post/2017-09-11-graph-theory-expenses-management/</guid>
      <description>&lt;p&gt;With the end-of-year celebrations, we all had some expenses to manage,
some of them shared with friends, and we all have this eternal problem
of splitting them fairly.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Les bons comptes font les bons amis.&lt;/em&gt;
French wisdom&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Applications like &lt;a href=&#34;https://tricount.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tricount&lt;/a&gt; or
&lt;a href=&#34;https://www.splitwise.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Splitwise&lt;/a&gt; became famous precisely by
solving this problem for you: just enter the expenses one by one, with who
owes whom and you&amp;rsquo;ll get the simplest transactions to balance the amounts at
the end.&lt;/p&gt;
&lt;p&gt;In this post, we&amp;rsquo;ll model the expense balancing problem from a graph
perspective and see how to come up with a solution using Julia and the
JuliaGraphs ecosystem [1].&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;


&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Table of Contents&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;ol&gt;
        &lt;li&gt;&lt;a href=&#34;#the-expenses-model&#34;&gt;The expenses model&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#reducing-expenses&#34;&gt;Reducing expenses&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#breaking-strongly-connected-components&#34;&gt;Breaking strongly connected components&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#expenses-as-a-flow-problem&#34;&gt;Expenses as a flow problem&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#conclusion-perspective-and-note-on-gphc&#34;&gt;Conclusion, perspective and note on GPHC&lt;/a&gt;&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/nav&gt;
&lt;/details&gt;

&lt;h2 id=&#34;the-expenses-model&#34;&gt;The expenses model&lt;/h2&gt;
&lt;p&gt;Say that we have $n$ users involved in the expenses. An expense
$\delta$ is defined by an amount spent $\sigma$, the user who paid the
expense $p$ and a non-empty set of users who are accountable for
this expense $a$.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\delta = (\sigma, p, a)$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The total of all expenses $\Sigma$ can be though of as: for any two users $u_i$ and $u_j$,
the total amount that $u_i$ spent for $u_j$. So the expenses are a vector of
triplets &lt;em&gt;(paid by, paid for, amount)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As an example, if I went out for
pizza with Joe and paid 8GPHC for the two of us, the expense is modeled as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\delta = (\sigma: 8GPHC, p: Mathieu, a: [Mathieu, Joe])$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now considering I don&amp;rsquo;t keep track of money I owe myself, the sum of all expenses
is the vector composed of one triplet:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\Sigma = [(Mathieu, Joe, \frac{8}{2} = 4)]$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Julia, the expense information can be translated to a structure:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; User &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; GraphCoin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Float16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Expense&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    payer&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;User&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    amount&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GraphCoin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    users&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Set&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;User&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2 id=&#34;reducing-expenses&#34;&gt;Reducing expenses&lt;/h2&gt;
&lt;p&gt;Now that we have a full representation of the expenses,
the purpose of balancing is to find a vector of transactions which cancels out
the expenses. A naive approach would be to use the transposed expense matrix
as a transaction matrix. If $u_i$ paid $\Sigma_{i,j}$ for $u_j$,
then $u_j$ paying back that exact amount to $u_i$ will solve the problem.
So we need in the worst case as many transactions after the trip as
$|u| \cdot (|u| - 1)$. For 5 users, that&amp;rsquo;s already 20 transactions,
how can we improve it?&lt;/p&gt;
&lt;h2 id=&#34;breaking-strongly-connected-components&#34;&gt;Breaking strongly connected components&lt;/h2&gt;
&lt;p&gt;Suppose that I paid the pizza slice to Joe for 4GPHC, but he bought me an ice
cream for 2GPHC the day after. In the naive models, we would have two
transactions after the trip: he give me 4GPHC and I would give him 2GPHC. That
does not make any sense, he should simply pay the difference between what he
owes me and what I owe him. For any pair of users, there should only be
at most one transaction from the most in debt to the other, this result in the
worst case of $\frac{|u| \cdot (|u| - 1)}{2}$ transactions, so 10 transactions
for 5 people.&lt;/p&gt;
&lt;p&gt;Now imagine I still paid 4GPHC for Joe, who paid 2GPHC for Marie, who paid 4GPHC
for me. In graph terminology, this is called a
&lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Strongly_connected_component&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;strongly connected component&lt;/a&gt;&lt;/em&gt;.
The point here is that transactions will flow from one user to the next one,
and back to the first.&lt;/p&gt;
&lt;p&gt;If there is a cycle, we can find the minimal due sum within it. In our 3-people
case, it is 2GPHC. That&amp;rsquo;s the amount which is just moving from hand to hand and
back at the origin: it can be forgotten. This yields a new net debt:
I paid 2GPHC for Joe, Marie paid 2GPHC for me. We reduced the number of
transactions and the amount due thanks to this cycle reduction.&lt;/p&gt;
&lt;h2 id=&#34;expenses-as-a-flow-problem&#34;&gt;Expenses as a flow problem&lt;/h2&gt;
&lt;p&gt;To simplify the problem, we can notice we don&amp;rsquo;t actually care about who paid
whom for what, a fair reimbursement plan only requires two conditions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;All people who are owed some money are given at least that amount&lt;/li&gt;
&lt;li&gt;People who owe money don&amp;rsquo;t pay more than the net amount they ought to pay&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can define a directed flow network with users split in two sets of vertices,
depending on whether they owe or are owed money. We call these two sets $V_1$
and $V_2$ respectively.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There is an edge from any node of $V_1$ to any node of $V_2$.&lt;/li&gt;
&lt;li&gt;We define a &lt;em&gt;source&lt;/em&gt; noted $s$ connected to all vertices in $V_1$, the edge
from $s$ to any node of $V_1$ has a capacity equal to what they owe.&lt;/li&gt;
&lt;li&gt;We define a &lt;em&gt;sink&lt;/em&gt; noted $t$ to which all vertices in $V_2$ connect, with
infinite capacity and a demand (the minimal flow that has to pass through) equal
to what they are owed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this model, GraphCoins will flow from user owing money to users who are
owed money, see &lt;a href=&#34;https://en.wikipedia.org/wiki/Maximum_flow_problem&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wikipedia description of the flow problem&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;computing-net-owed-amount-per-user&#34;&gt;Computing net owed amount per user&lt;/h3&gt;
&lt;p&gt;Given a vector of expenses, we should be able to build the matrix holding what
is owed in net from a user to another:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Builds the matrix of net owed GraphCoins
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; compute_net_owing(expenses&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Vector&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;Expense&lt;/span&gt;}, nusers&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    owing_matrix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(GraphCoin, nusers, nusers)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# row owes to column&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; expense &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; expenses
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; user &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; expense&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;users
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; user &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; expense&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;payer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                owing_matrix[user,expense&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;payer] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; expense&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;amount &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; length(expense&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;users)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# compute net owed amount&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    net_owing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(GraphCoin, nusers, nusers)    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;nusers&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;nusers
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; owing_matrix[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; owing_matrix[j,i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                net_owing[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; owing_matrix[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; owing_matrix[j,i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;elseif&lt;/span&gt; owing_matrix[i,j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; owing_matrix[j,i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                net_owing[j,i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; owing_matrix[j,i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; owing_matrix[i,j]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; net_owing
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From that matrix, we should determine the net amount any user owes or is owed:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    What is owed to a given user (negative if user owes money)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; net_owed_user(net_owing&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Matrix&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;GraphCoin&lt;/span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (sum(net_owing,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum(net_owing,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;))[&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;sum&lt;/code&gt; function used with &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; sums a matrix over its rows, columns
respectively. This computes a difference between what a user is owed and what
they owe.&lt;/p&gt;
&lt;h3 id=&#34;building-the-graph-and-the-corresponding-flow-problem&#34;&gt;Building the graph and the corresponding flow problem&lt;/h3&gt;
&lt;p&gt;A flow problem is determined by the directed graph (nodes and directed edges),
the minimal flow for any edge, a maximal flow or capacity for any edge and a
cost of having a certain flow going through each edge.&lt;/p&gt;
&lt;p&gt;First, we need to import LightGraphs, the core package of the JuliaGraph
ecosystem containing essential types.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; LightGraphs; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; lg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LightGraphs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Note that I use explicit package import (not &lt;code&gt;using&lt;/code&gt;), an habit I
kept from using Python and that I consider more readable than importing
the whole package into the namespace. &lt;code&gt;lg&lt;/code&gt; has become my usual name for the
LightGraphs package.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; build_graph(net_owing&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Matrix&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;GraphCoin&lt;/span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nusers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; size(net_owing,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    g &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;DiGraph(nusers &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    source &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nusers &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sink &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nusers &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    net_user &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; net_owed_user(net_owing)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    v1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [idx &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;nusers &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; net_user[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    v2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [idx &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;nusers &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; net_user[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    capacity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(GraphCoin, nusers&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,nusers&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    demand &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(GraphCoin, nusers&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,nusers&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    maxcap &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum(net_owing)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u1 &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; v1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_edge!(g,source,u1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        capacity[source,u1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;net_user[u1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u2 &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; v2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_edge!(g,u1,u2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            capacity[u1,u2] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; maxcap
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u2 &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; v2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_edge!(g,u2,sink)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        capacity[u2,sink] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; maxcap
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        demand[u2,sink] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; net_user[u2]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (g, capacity, demand)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function builds our graph structure and all data we need attached.&lt;/p&gt;
&lt;h3 id=&#34;solving-the-flow-problem&#34;&gt;Solving the flow problem&lt;/h3&gt;
&lt;p&gt;Now that the components are set, we can solve the problem using another
component of the JuliaGraphs ecosystem specialized for flow problems:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using LightGraphsFlows: mincost_flow
using Clp: ClpSolver
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We also need a Linear Programming solver to pass to the flow solver, all we
have to do is bundle the pieces together:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; solve_expense(expenses&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Vector&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;Expense&lt;/span&gt;}, nusers&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (g, capacity, demand) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; build_graph(compute_net_owing(expenses, nusers))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    flow &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mincost_flow(g, capacity, demand, ones(nusers&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,nusers&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;), ClpSolver(), nusers&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, nusers&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; flow[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We truncate the &lt;code&gt;flow&lt;/code&gt; matrix because we are only interested in what users
are paying each other, not in the flows from and to the source and sink.&lt;/p&gt;
&lt;h3 id=&#34;trying-out-our-solution&#34;&gt;Trying out our solution&lt;/h3&gt;
&lt;p&gt;Now that all functions are set, we can use it on any expense problem:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;expenses &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Expense(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;Set&lt;/span&gt;([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Expense(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;Set&lt;/span&gt;([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;])),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Expense(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;Set&lt;/span&gt;([&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;solve_expense(expenses, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3×3 Array{Float64,2}:
  0.0  0.0  0.0
 18.0  0.0  0.0
  3.0  0.0  0.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the result, each row pays to each column and voilà! Our three users don&amp;rsquo;t
have to feel the tension of unpaid debts anymore.&lt;/p&gt;
&lt;h2 id=&#34;conclusion-perspective-and-note-on-gphc&#34;&gt;Conclusion, perspective and note on GPHC&lt;/h2&gt;
&lt;p&gt;We managed to model our specific problem using &lt;em&gt;LightGraphs.jl&lt;/em&gt; and the
associated flow package pretty easily. I have to admit being biased since
I contributed to the JuliaGraphs ecosystem, if your impression is different
or if you have some feedback, don&amp;rsquo;t hesitate to file an issue on the
&lt;a href=&#34;https://github.com/JuliaGraphs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;corresponding package&lt;/a&gt;, some awesome people
will help you figure things out as they helped me.&lt;/p&gt;
&lt;p&gt;There is one thing we ignored in our model, it&amp;rsquo;s the number of transactions
realized. Using this as an objective turns the problem into a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Integer_programming#Variants&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mixed-Integer Linear Programming&lt;/a&gt; one,
which are much harder to solve and cannot use simple flow techniques. However,
I still haven&amp;rsquo;t found a case where our simple approach does not yield the
smallest number of transactions.&lt;/p&gt;
&lt;p&gt;Final word: I started the idea of this article long before the crypto-madness
(September actually), when currencies where still considered as boring,
nerdy or both, sorry about following the (late) hype. I even changed
GraphCoin symbol to GPHC because I found another one with which my initial
name conflicted.&lt;/p&gt;
&lt;p&gt;If you have questions or remarks on LightGraphs, LightGraphsFlows, the article
or anything related, don&amp;rsquo;t hesitate to &lt;a href=&#34;http://twitter.com/matbesancon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ping me&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Edits:&lt;br&gt;
Special thanks to &lt;a href=&#34;http://www.bromberger.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Seth Bromberger&lt;/a&gt; for the review.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The cover image was created using
&lt;a href=&#34;https://github.com/JuliaGraphs/GraphPlot.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphPlot.jl&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[1] James Fairbanks Seth Bromberger and other contributors. Juliagraphs/LightGraphs.jl:
Lightgraphs, 2017, &lt;a href=&#34;https://doi.org/10.5281/zenodo.889971&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.5281/zenodo.889971&lt;/a&gt;. DOI: 10.5281/zenodo.889971&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
